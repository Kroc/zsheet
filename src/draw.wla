; ZSheet (c) copyright Kroc Camen 2022. unless otherwise noted,
; licenced under a MIT licence; you may reuse and modify this code
; how you please as long as you retain the copyright notice
;

; a view is the size/position of a window into the current sheet
;
.STRUCT View
        col             BYTE    ; top-left column in view (scroll-offset)
        row             WORD    ; top-left row in view (scroll-offset)
        y               BYTE    ; screen-row the view begins at
        h               BYTE    ; number of screen-rows visible in the view
        ; TODO: to support selection ranges, and even disparate selections;
        ; (e.g. "A3,C6,B9") this will have to be a lot more complex
        cursor          INSTANCEOF Rc
.ENDST

.RAMSECTION "ZP_VIEWS"  SLOT "ZP" RETURNORG
        zp_view         INSTANCEOF View
.ENDS

.RAMSECTION "ZP_SCREEN" SLOT "ZP" RETURNORG
        ; a destination pointer for copying screen rows
        zp_screen_copy  WORD
        ; a vector specifically for putting characters to screen
        ; -- this is always the current drawing address on screen
        zp_screen       WORD
        ; a destination pointer for copying colour-RAM rows
        zp_colour_copy  WORD
        ; as with `zp_screen` this is the position in colour RAM.
        ; the two are kept in sync when using `bump_addr`
        zp_colour       WORD
.ENDS

.RAMSECTION "ZP_MODE" SLOT "ZP" RETURNORG
        ; a bitmask ORed with characters before being printed;
        ; use %10000000 ($80) for reverse-video and %01000000 to force capitals
        zp_screen_mask  BYTE
        ; current printing colour
        zp_print_colour BYTE
.ENDS

.RAMSECTION "ZS_WORK" SLOT "LORAM" RETURNORG
        ; a list of the column widths currently on screen:
        ; the maxmimum number of columns that can fit on screen is based
        ; upon the minimum allowed column-wdith, +1 because the 'column
        ; width' doesn't include the borders that are automatically
        ; inserted between rows
        column_pos      DS (SYS_SCREEN_COLS / (ZS_COL_WIDTH_MIN+1)) + 1
.ENDS


; tables for looking up the screen / colour-RAM
; addresses for each screen row:
;
.SECTION "ZS_SCREEN_ADDR" BITWINDOW 8
;###############################################################################

screen_addrs:
;===============================================================================
screen_addrs_lo:
;-------------------------------------------------------------------------------
.REPEAT SYS_SCREEN_ROWS INDEX R
        .BYTE <(zs_screen + R * SYS_SCREEN_COLS)
.ENDR
;-------------------------------------------------------------------------------
screen_addrs_hi:
;-------------------------------------------------------------------------------
.REPEAT SYS_SCREEN_ROWS INDEX R
        .BYTE >(zs_screen + R * SYS_SCREEN_COLS)
.ENDR
;-------------------------------------------------------------------------------
colour_addrs_hi:
;-------------------------------------------------------------------------------
.REPEAT SYS_SCREEN_ROWS INDEX R
        .BYTE >($d800 + R * SYS_SCREEN_COLS)
.ENDR

;###############################################################################
.ENDS


set_addr:
;===============================================================================
; set the screen and colour-RAM drawing addresses,
; given a screen-row (not a sheet row!)
;
; in:   X       screen row to set drawing address for
; out:  X, Y    (preserved)
;       A       (clobbered)
;-------------------------------------------------------------------------------
        lda.w screen_addrs_lo, x
        sta zp_screen+LO        ; the lo-bytes are shared between
        sta zp_colour+LO        ; the screen-RAM and colour-RAM
        lda.w screen_addrs_hi, x
        sta zp_screen+HI
        lda.w colour_addrs_hi, x
        sta zp_colour+HI
        
        rts

set_addr_copy:
;===============================================================================
        ; set the main addresses first, and then fall through to copy them
        jsr set_addr

copy_addr:
;===============================================================================
; copies the current screen and colour RAM addresses used for a block copy:
;-------------------------------------------------------------------------------
        ldy # 2
-       lda zp_screen-1, y
        sta zp_screen_copy-1, y
        lda zp_colour-1, y
        sta zp_colour_copy-1, y
        dey
        bne -

        rts


bump_addr_copy:
;===============================================================================
; bump the main printing addresses forward and the copy addresses to match:
;
; when indexing using Y, this routine is used to bump the 16-bit source &
; destination address up according to the value in Y to avoid an 8-bit
; rollover in Y
;
; in:   Y       offset to add to `zp_screen(_copy)` & `zp_colour(_copy)`
; out:  Y       set to zero
;       X       (preserved)
;       A       (clobbered)
;-------------------------------------------------------------------------------
        tya                     ; take current offset
        clc                     ; prepare for math!
        adc zp_screen_copy+LO   ; add Y to the address lo-byte
        bcc +                   ; if it doesn't overflow, skip the hi-byte
        inc zp_screen_copy+HI   ; increment the print address hi-byte,
        inc zp_colour_copy+HI   ; and the colour address likewise
+       sta zp_screen_copy+LO   ; update the address lo-byte --
        sta zp_colour_copy+LO   ; these are the same between print & colour

        ; fall through to bump the main addresses and reset Y
        ;

bump_addr:
;===============================================================================
; add Y to `zp_screen` & `zp_colour`
;
; when indexing using Y, this routine is used to bump the 16-bit address
; up according to the value in Y to avoid an 8-bit rollover in Y
;
; in:   Y       offset to add to `zp_screen` & `zp_colour`
; out:  Y       set to zero
;       X       (preserved)
;       A       (clobbered)
;-------------------------------------------------------------------------------
        tya                     ; take current offset
        clc                     ; prepare for math!
        adc zp_screen+LO        ; add Y to the address lo-byte
        bcc +                   ; no overflow? skip hi-bytes
        inc zp_screen+HI        ; increment the print address hi-byte,
        inc zp_colour+HI        ; and the colour address likewise
+       sta zp_screen+LO        ; update the address lo-byte --
        sta zp_colour+LO        ; shared between print & colour
        
        ; Y is set back to zero so that `lda [zp_screen], y`
        ; reflects the same address as before!
        ldy # 0
        
        rts


.RAMSECTION "ZP_DRAWRC" SLOT "ZP" RETURNORG
        ;-----------------------------------------------------------------------
        zp_drawrc       INSTANCEOF Rc
.ENDS


draw_screen:
;===============================================================================
; does a complete screen draw
;
;-------------------------------------------------------------------------------
        ; copy the current view row/column into
        ; the row/col reference used during drawing
        lda zp_view.col
        sta zp_drawrc.col
        lda zp_view.row+LO
        sta zp_drawrc.row+LO
        lda zp_view.row+HI
        sta zp_drawrc.row+HI

        jsr draw_tabs
        jsr draw_status_bar
        jsr draw_formula_bar
        jmp draw_sheet          ; do a complete redraw of the view


draw_tabs:
;===============================================================================
; do a complete draw of the table tabs:
;-------------------------------------------------------------------------------
        ldx # 0
        jsr set_addr

        clc                     ; clear reverse-video,
        asl zp_screen_mask      ; if set

        ldy # 0
        ldx # SYS_SCREEN_COLS
        lda # VIC_CYAN
        jmp fast_spaces_colour


draw_status_bar:
;===============================================================================
; do a complete draw of the status bar:
;-------------------------------------------------------------------------------
        ldx # SYS_SCREEN_ROWS-2 ; move to the 2nd to last screen row,
        jsr set_addr            ; where the status bar is
        
        ; set reverse-video drawing
        lda # %10000000
        sta zp_screen_mask

        ; print spaces:
        ldy # 0                 ; starting at the left,
        ldx # SYS_SCREEN_COLS   ; across the whole screen,
        lda # VIC_CYAN          ; with this colour
        jmp fast_spaces_colour


draw_formula_bar:
;===============================================================================
; do a complete draw of the table tabs:
;-------------------------------------------------------------------------------
        ldx # 0
        jsr set_addr

        clc                     ; clear reverse-video,
        asl zp_screen_mask      ; if set

        ldy # 0
        ldx # SYS_SCREEN_COLS
        lda # VIC_CYAN
        jmp fast_spaces_colour


draw_sheet:
;===============================================================================
; does a complete draw of the spreadsheet view
;
;-------------------------------------------------------------------------------
        jsr draw_col_headers
        jmp draw_rows


draw_col_headers:
;===============================================================================
; draws the column headers across the screen
;
;-------------------------------------------------------------------------------
        ; set the screen address to the 2nd screen row
        ldx # 1
        jsr set_addr

        ; left-hand offset, this needs to be based upon
        ; the number of characters in the view's first row!
        ;
        ; fill in the corner bit of the sheet:
        ;
        sec                     ; enable reverse-video printing
        ror zp_screen_mask
        ldy # 0                 ; start screen col...
        ldx # 3                 ; width...
        lda # VIC_CYAN          ; colour...
        jsr fast_spaces_colour  ; print!

        ; first column to begin drawing
        ldx zp_drawrc.col

        ; keep drawing columns until we reach the edge
        ; of the screen, or we reach column 255 ("IV")!
        ;
-       lda # 2                 ; column width
        jsr draw_col_header     ; draw the column header
        cpy # SYS_SCREEN_COLS   ; have we hit the edge of the screen?
        beq +                   ; if so -- stop drawing column headers
        inx                     ; move to next column number,
        bne -                   ; and draw again

        ; when the column headers hit the edge of the screen, Y will already
        ; be equal to the screen width and `bump_addr` will update `zp_screen`
        ; and wrap Y back to zero. if we hit the last column ("IV") before
        ; hitting the edge of the screen, we need to clear the right-hand
        ; side of the screen to avoid grabage from the previous scroll
        ;
        ; calculate the remaining number of screen cols:
        ; we can't just subtact Y from A on the 6502, but we can simulate
        ; a subtraction through an addition that wraps around!
        ;
        tya                     ; (current screen pos)
        ; add the inverted value of the screen width
        adc # $ff-SYS_SCREEN_COLS
        eor # %11111111         ; flip the bits back to positive
        tax
        asl zp_screen_mask      ; turn off reverse-video
        jsr fast_spaces         ; print spaces to the end of the screen

        ; add Y to the screen address to reset Y to zero on the next screen row
+       jmp bump_addr


draw_col_header:
;===============================================================================
; draw a column header:
;
; drawing will stop if the column hits the edge of the screen
;
; in:   A       column width. the right border is added automatically
;       X       column number (0-255), which will be converted to alpha
;       Y       starting screen position, where `zp_screen` is screen row
;               addr, e.g. `zp_screen` = $0400, Y is sceen col. 0-39
;
; out:  X       the column number is not incremented for the benefit
;               of printing a column of the sheet vertically
;       Y       the screen position is moved forward over the column
;       A       (clobbered)
;===============================================================================
        sta zp_a                ; set aside column width
        stx zp_x                ; set aside column index
        sty zp_y                ; set aside current screen position

        ; when printing, X will be the number of chars to print;
        ; to begin with, set this to the column width
        tax
        
        lda # %10000000
        sta zp_screen_mask

        clc
        lda # SYS_SCREEN_COLS
        sbc zp_y
        cmp zp_a
        bcs +

        ; use the clipped column-width instead
        tax
        inx

        ; draw header background:
        ; note that X already contains column width to draw
+       lda # VIC_CYAN
        jsr fast_spaces_colour  ; NOTE: does not modify carry!
        bcc +
        
        ; print the right-border:
        lda # $90
        sta [zp_screen], y
        lda # VIC_CYAN
        sta [zp_colour], y
        iny

        ; print the column title ("A"-"IV")
        ;-----------------------------------------------------------------------
+       sty zp_a                ; remember screen position after column
        ldy zp_y                ; go back to start of column header

        ldx zp_x                ; get column index
        jsr col_index_to_alpha_x; convert to letter(s)
        cpx # $40               ; is there an upper-letter?
        beq +                   ; if not, skip over printing upper-letter

        pha                     ; put aside lower-letter
        txa                     ; get upper-letter
        ora # %10000000         ; set reverse video
        sta [zp_screen], y      ; print upper-letter
        iny                     ; move to next character on screen
        pla                     ; retrieve lower-letter

        cpy # SYS_SCREEN_COLS
        beq @end

+       ora # %10000000         ; set reverse video
        sta [zp_screen], y      ; print lower-letter

@end:   ldx zp_x                ; restore column index
        ldy zp_a                ; restore screen column
        rts


draw_rows:
;===============================================================================
; draw a series of rows:
;
;-------------------------------------------------------------------------------
        ldx zp_view.h           ; number of rows to draw (1-based)
        lda zp_drawrc.row+LO    ; start from the row defined in `zp_drawrc`

-       jsr draw_row
        inc zp_drawrc.row+LO    ; move to next row
        dex
        bne -

        rts


draw_row:
;===============================================================================
; draws a full sheet row, including the row number:
; this routine is used to fill in a row after scrolling vertically
;
; in:   X       row number; TODO: this to be expanded to 16-bit
; out:  Y       Y, screen-column, is reset to 0 and `zp_screen` /
;               `zp_colour` are moved forward to the next screen row
;       X       (preserved)
;       A       (clobbered)
;-------------------------------------------------------------------------------
        stx zp_x                ; backup X

        ldy # 0                 ; start on the left edge of the screen
        lda zp_drawrc.row+LO    ; TODO: expand to 16-bit
        jsr draw_row_number
        
        ; set colour:
        ldy # 0
        ldx # 3
        lda # VIC_CYAN
        asl zp_screen_mask      ; disable reverse-video drawing
        jsr fast_colour

        ; reset the column number to where the view
        ; is currently scrolled horizontally
        lda zp_view.col
        sta zp_drawrc.col
        
        ; keep drawing cells until we reach the edge of the screen:
        ;
-       lda # 2                 ; cell width
        jsr draw_empty_cell     ; draw an empty cell
        cpy # SYS_SCREEN_COLS   ; have we hit the edge of the screen?
        beq +                   ; if yes, stop drawing
        inc zp_drawrc.col       ; move to next column number,
        bne -                   ; and draw again

        ; when the cells hit the edge of the screen, Y will already be equal
        ; to the screen width and `bump_addr` will update `zp_screen` and wrap
        ; Y back to zero. if we hit the last column ("IV") before hitting the
        ; edge of the screen, we need to clear the right-hand side of the
        ; screen to avoid grabage from the previous scroll
        ;
        ; calculate the remaining number of screen cols:
        ; we can't just subtact Y from A on the 6502, but we can simulate
        ; a subtraction through an addition that wraps around!
        ;
        tya                     ; (current screen pos)
        ; add the inverted value of the screen width
        adc # $ff-SYS_SCREEN_COLS
        eor # %11111111         ; flip the bits back to positive
        tax
        asl zp_screen_mask      ; turn off reverse-video
        jsr fast_spaces         ; print spaces to the end of the screen

+       ldx zp_x                ; restore row number

        ; add Y to the screen address to reset
        ; Y to zero on the next screen row
        jmp bump_addr


draw_row_number:
;===============================================================================
        ; enable reverse video for column number
        lda # %10000000
        sta zp_screen_mask
        
        lda zp_drawrc.row+LO
        jmp print_number_byte


draw_empty_cell:
;===============================================================================
; fast draw an empty cell (and its right border):
;
; drawing will stop if the column hits the edge of the screen
;
; in:   A       cell width. the right border is added automatically
;       Y       starting screen position, where `zp_screen` is screen row
;               addr, e.g. `zp_screen` = $0400, Y is sceen col. 0-39
;
; out:  A       (clobbered)
;-------------------------------------------------------------------------------
        sta zp_a                ; set aside column width
        sty zp_y                ; set aside current screen position
        
        ; when printing, X will be the number of chars to print;
        ; to begin with, set this to the column width
        tax
        
        clc
        lda # SYS_SCREEN_COLS
        sbc zp_y
        cmp zp_a
        bcs +

        tax                     ; use the clipped cell-width instead
        inx

        ; draw cell background:
+       lda # VIC_CYAN
        jsr fast_spaces_colour  ; NOTE: does not modify carry!
        bcc +
        
        ; print the right-border:
        lda # $11
        sta [zp_screen], y
        lda # VIC_CYAN
        sta [zp_colour], y
        iny

+       rts


fast_spaces_colour:
;===============================================================================
; print up to 40 spaces, quickly, with colour set
;
; in:   A       colour code
;       X       number of spaces to print
;       Y       current offset from `zp_screen`/`zp_colour` to start at
;
; out:  Y       Y is returned incremented by X;
;               i.e. ready to write next value
;       X       (preserved)
;       carry   (preserved)
;       A       (clobbered)
;-------------------------------------------------------------------------------
        sty.w @ldy+1            ; preserve Y

        ; do the colouring first since A specifies the colour code
        jsr fast_colour

        ; restore Y to go back to the start position and draw the spaces
@ldy    ldy # 0

fast_spaces:                                                            ;+6=6
;===============================================================================
; print up to 40 spaces, quickly
;
; in:   X       number of spaces to print
;       Y       current offset from `zp_screen` to start at
;
; out:  Y       Y is returned incremented by X;
;               i.e. ready to write next value
;       X       (preserved)
;       carry   (preserved)
;       A       (clobbered)
;-------------------------------------------------------------------------------
        lda.w spaces_table, x   ; look up lo-byte of address to jump to ;+4=10
        sta.w @jmp+1            ; change jump address to match          ;+4=14
        
        lda # ' '               ; use a space character                 ;+2=16
        ora zp_screen_mask      ; apply reverse-video, if set (bit 7)   ;+3=19
@jmp    jmp spaces_chars                                                ;+3=22


fast_colour:                                                            ;+6=6
;===============================================================================
; colour up to 40 screen cells, quickly
;
; in:   A       colour code
;       X       number of cells to colour
;       Y       current offset from `zp_screen` to start at
;
; out:  Y       Y is returned incremented by X;
;               i.e. ready to write next value
;       X       (preserved)
;       carry   (preserved)
;       A       (clobbered)
;-------------------------------------------------------------------------------
        pha                     ; put colour value aside                ;+3=

        lda.w colour_table, x   ; look up lo-byte of address to jump to ;+4=
        sta.w @jmp+1            ; change jump address to match          ;+4=
        
        pla                     ; restore colour value                  ;+3=
@jmp    jmp colour_chars                                                ;+3=


; NOTE: this section *must* be aligned to a 256-byte page!
;
.SECTION fast_write     ALIGN 256       RETURNORG
;###############################################################################
; note that this routine occupies 121 bytes and a second one that follows
; occupies the same again, totalling 242 bytes. for speed purposes, these
; routines *must* fit into one 256-byte page so that only the low byte of
; the addresses are required

spaces_chars:
;===============================================================================
@chr40: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr39: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr38: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr37: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr36: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr35: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr34: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr33: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr32: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr31: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr30: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr29: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr28: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr27: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr26: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr25: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr24: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr23: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr22: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr21: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr20: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr19: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr18: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr17: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr16: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr15: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr14: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr13: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr12: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr11: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr10: sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr9:  sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr8:  sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr7:  sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr6:  sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr5:  sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr4:  sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr3:  sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr2:  sta [zp_screen], y                                              ;+6
        iny                                                             ;+2
@chr1:  sta [zp_screen], y                                              ;+6
        iny                                                             ;+2

@rts:   rts                                                             ;*+6

colour_chars:
;===============================================================================
@chr40: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr39: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr38: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr37: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr36: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr35: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr34: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr33: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr32: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr31: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr30: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr29: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr28: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr27: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr26: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr25: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr24: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr23: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr22: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr21: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr20: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr19: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr18: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr17: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr16: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr15: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr14: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr13: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr12: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr11: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr10: sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr9:  sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr8:  sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr7:  sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr6:  sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr5:  sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr4:  sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr3:  sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr2:  sta [zp_colour], y                                              ;+6
        iny                                                             ;+2
@chr1:  sta [zp_colour], y                                              ;+6
        iny                                                             ;+2

@rts:   rts                                                             ;+6

        ; skip enough bytes to reach the beginning of the next 256-byte page
        .DSB 14, $00

spaces_table:
;===============================================================================
        .BYTE   <spaces_chars@rts
        .BYTE   <spaces_chars@chr1,     <spaces_chars@chr2
        .BYTE   <spaces_chars@chr3,     <spaces_chars@chr4
        .BYTE   <spaces_chars@chr5,     <spaces_chars@chr6
        .BYTE   <spaces_chars@chr7,     <spaces_chars@chr8
        .BYTE   <spaces_chars@chr9,     <spaces_chars@chr10
        .BYTE   <spaces_chars@chr11,    <spaces_chars@chr12
        .BYTE   <spaces_chars@chr13,    <spaces_chars@chr14
        .BYTE   <spaces_chars@chr15,    <spaces_chars@chr16
        .BYTE   <spaces_chars@chr17,    <spaces_chars@chr18
        .BYTE   <spaces_chars@chr19,    <spaces_chars@chr20
        .BYTE   <spaces_chars@chr21,    <spaces_chars@chr22
        .BYTE   <spaces_chars@chr23,    <spaces_chars@chr24
        .BYTE   <spaces_chars@chr25,    <spaces_chars@chr26
        .BYTE   <spaces_chars@chr27,    <spaces_chars@chr28
        .BYTE   <spaces_chars@chr29,    <spaces_chars@chr30
        .BYTE   <spaces_chars@chr31,    <spaces_chars@chr32
        .BYTE   <spaces_chars@chr33,    <spaces_chars@chr34
        .BYTE   <spaces_chars@chr35,    <spaces_chars@chr36
        .BYTE   <spaces_chars@chr37,    <spaces_chars@chr38
        .BYTE   <spaces_chars@chr39,    <spaces_chars@chr40

colour_table:
;===============================================================================
        .BYTE   <colour_chars@rts
        .BYTE   <colour_chars@chr1,     <colour_chars@chr2
        .BYTE   <colour_chars@chr3,     <colour_chars@chr4
        .BYTE   <colour_chars@chr5,     <colour_chars@chr6
        .BYTE   <colour_chars@chr7,     <colour_chars@chr8
        .BYTE   <colour_chars@chr9,     <colour_chars@chr10
        .BYTE   <colour_chars@chr11,    <colour_chars@chr12
        .BYTE   <colour_chars@chr13,    <colour_chars@chr14
        .BYTE   <colour_chars@chr15,    <colour_chars@chr16
        .BYTE   <colour_chars@chr17,    <colour_chars@chr18
        .BYTE   <colour_chars@chr19,    <colour_chars@chr20
        .BYTE   <colour_chars@chr21,    <colour_chars@chr22
        .BYTE   <colour_chars@chr23,    <colour_chars@chr24
        .BYTE   <colour_chars@chr25,    <colour_chars@chr26
        .BYTE   <colour_chars@chr27,    <colour_chars@chr28
        .BYTE   <colour_chars@chr29,    <colour_chars@chr30
        .BYTE   <colour_chars@chr31,    <colour_chars@chr32
        .BYTE   <colour_chars@chr33,    <colour_chars@chr34
        .BYTE   <colour_chars@chr35,    <colour_chars@chr36
        .BYTE   <colour_chars@chr37,    <colour_chars@chr38
        .BYTE   <colour_chars@chr39,    <colour_chars@chr40
;###############################################################################
.ENDS


scroll_view_down:
;===============================================================================
        ldx zp_view.h           ; number of rows to scroll
        dex                     ; less one because a new row will be drawn in

scroll_down:
;===============================================================================
; copy a series of rows upwards, effectively scrolling the sheet down:
;
; (this is currently hard-coded whilst I work out the details)
;-------------------------------------------------------------------------------
        ; we could copy 40 columns each loop but bumping the source and
        ; destination addresses forward is expensive so instead we do as many
        ; rows as will fit within an 8-bit index (i.e. 6, for 40 columns)
        ;
        lda.w copy_rows_remainder-1, x
        sta.w @rem+1
        ; given the number of rows to copy, lookup in a table the number of
        ; complete iterations required (6 rows per iteration for 40 columns)
        lda.w copy_rows_iterations-1, x
        ; if this is zero, then there is less than one full iteration
        ; of chars to copy (e.g. <6 rows for 40 columns)
        beq @rem
        ; write this count into the loop
        sta.w @ldx+1
        
        ; set the source and destination addresses
        ; to the 2nd row of the view
        ldx zp_view.y
        inx
        jsr set_addr_copy
        ; now set the source address to the first row
        dex
        jsr set_addr

@ldx    ldx # 1
        ;-----------------------------------------------------------------------
@copy:  ldy # 0
-       lda [zp_screen_copy], y
        sta [zp_screen], y
        lda [zp_colour_copy], y
        sta [zp_colour], y
        ; TODO: can we do this in reverse instead?
        iny
        cpy # floor(256 / SYS_SCREEN_COLS) * SYS_SCREEN_COLS
        bcc -

        ; bump the source and destination addresses
        ; forward as Y has reached its limit
        jsr bump_addr_copy

        dex
        bne @copy

        ; copy remainder
        ;-----------------------------------------------------------------------
@rem:   ldx # 0
        beq @rts

-       lda [zp_screen_copy], y
        sta [zp_screen], y
        lda [zp_colour_copy], y
        sta [zp_colour], y
        iny
        dex
        bne -

        jmp bump_addr_copy

@rts:   rts


scroll_view_up:
;===============================================================================
        ; we need to start with copying the 2nd-to-last row down to the
        ; last row and then walk up the screen, copying rows down by one
        clc
        lda.b zp_view.y
        adc.b zp_view.h
        tax
        dex
        dex
        jsr set_addr_copy
        ; now set the source address to the previous row
        inx
        jsr set_addr

        ldx zp_view.h
        dex
        ;-----------------------------------------------------------------------
@copy:  ldy # SYS_SCREEN_COLS-1
-       lda [zp_screen_copy], y
        sta [zp_screen], y
        lda [zp_colour_copy], y
        sta [zp_colour], y
        dey
        bpl -

@next:  sec
        lda.b zp_screen+LO
        sbc # SYS_SCREEN_COLS
        bcs +
        dec.b zp_screen+HI
        dec.b zp_colour+HI
        sec                     ; set carry only when needed to save 2 cycles
+       sta.b zp_screen+LO
        sta.b zp_colour+LO

        lda.b zp_screen_copy+LO
        sbc # SYS_SCREEN_COLS
        bcs +
        dec.b zp_screen_copy+HI
        dec.b zp_colour_copy+HI
+       sta.b zp_screen_copy+LO
        sta.b zp_colour_copy+LO

        dex
        bne @copy

        rts


;;        ldy # 0
;;@copy:
;;@srcscr lda zs_screen, y
;;@dstscr sta zs_screen, y
;;@srcclr lda $d800, y
;;@dstclr sta $d800, y
;;        iny
;;        cpy #< (256 / SYS_SCREEN_COLS) * SYS_SCREEN_COLS
;;        bcc @copy
;;
;;        clc
;;        tya
;;        adc @srcscr+1
;;        bcc +
;;        inc @srcscr+2
;;        inc @srcclr+2
;;+       sta @srcscr+1
;;        sta @srcclr+1
;;        clc
;;        tya
;;        adc @dstscr+1
;;        bcc +
;;        inc @dstscr+2
;;        inc @dstclr+2
;;+       sta @dstscr+1
;;        sta @dstclr+1


.SECTION "COPYROWS_TABLE" BITWINDOW 8
;###############################################################################
.DEF    _ROWS_PER_ITER  floor( 256 / SYS_SCREEN_COLS )

;;copy_rows_index:
;;        ;-----------------------------------------------------------------------
;;        ; a small table of multiples of screen widths that fit within 1 byte
;;        ; e.g. with a 40-column screen: 40, 80, 120, 160, 200, 240; meaning
;;        ; that up to 6 screen rows can be traversed within a one byte index
;;        ;
;;.REPEAT _ROWS_PER_ITER INDEX I
;;        .BYTE I * SYS_SCREEN_COLS
;;.ENDR

copy_rows_iterations:
        ;-----------------------------------------------------------------------
        ; for a given number of rows, how many times a full-byte's worth of
        ; rows should be processed. the remainder is given in the next table
        ;
.REPEAT SYS_SCREEN_ROWS INDEX R
        .BYTE R / _ROWS_PER_ITER
.ENDR

copy_rows_remainder:
        ;-----------------------------------------------------------------------
.REPEAT SYS_SCREEN_ROWS INDEX R
        .BYTE (R+1) * SYS_SCREEN_COLS # _ROWS_PER_ITER * SYS_SCREEN_COLS
.ENDR

;###############################################################################
.ENDS