; ZSheet (c) copyright Kroc Camen 2022. unless otherwise noted,
; licenced under a MIT licence; you may reuse and modify this code
; how you please as long as you retain the copyright notice
;
; print.wla : screen output
;

sys_pet2asc:
;===============================================================================
; convert a PETSCII character code to ASCII:
;
; TODO: use a lookup-table for ROM-version?
;       (would require preserving Y)
;
; in:   A       character code
;
; out:  A       character code, converted  
;       X, Y    (preserved)
;
;-------------------------------------------------------------------------------
        ; is the character in the PETSCII upper-case range?
        ; note that the "case bit" in PETSCII is %10000000,
        ; not %00100000 as in ASCII
        ;
        cmp # PET_A_UP          ; "A" and above?
        bcc +                   ; no -- skip ahead
        cmp # PET_Z_UP+1        ; "Z" and below?
        bcs +                   ; no -- skip ahead

        ; adjust PETSCII upper-case $C1..$DA down to ASCII upper-case $41..$5A
        ; NOTE: carry is clear, so this subtracts an additional 1 for us!
        sbc # $80-1
        rts
        
        ; is the character in the PETSCII lower-case range?
        ;
+       cmp # PET_A_LO          ; "a" and above?
        bcc +                   ; no -- exit
        cmp # PET_Z_LO+1        ; "z" and below?
        bcs +                   ; no -- exit

        ; adjust PETSCII lower-case $41..$5A
        ; up to ASCII lower-case $61..$7A
        adc # $20

+       rts


sys_asc2pet:
;===============================================================================
; convert an ASCII character code to the system's native encoding:
; for Commodore machines, this is PETSCII
;
; TODO: use a lookup-table for ROM-version?
;       (would require preserving Y)
;
; in:   A       character code
;
; out:  A       character code, converted  
;       X, Y    (preserved)
;
;-------------------------------------------------------------------------------
        ; is the character in the ASCII lower-case range?
        ;
        cmp # $61               ; "a" and above?
        bcc +                   ; no -- skip ahead
        cmp # $7a+1             ; "z" and below?
        bcs +                   ; no -- skip ahead

        ; adjust ASCII lower-case $61..$7A down to PETSCII lower-case $41..$5A
        ; NOTE: carry is clear, so this subtracts an additional 1 for us!
        sbc # $20-1
        rts
        
        ; is the character in the ASCII upper-case range?
        ;
+       cmp # $41               ; "A" and above?
        bcc +                   ; no -- exit
        cmp # $5a+1             ; "z" and below?
        bcs +                   ; no -- exit

        ; adjust ASCII upper-case $41..$5A
        ; up to PETSCII upper-case $C1..$DA
        adc # $80

+       rts


print_asc:
;===============================================================================
; print an ASCII character:
;
; in:   A       ASCII-code
;
; out:  A       (clobbered)
;       X, Y    (preserved)
;-------------------------------------------------------------------------------
        jsr sys_asc2pet         ; convert ASCII code to native encoding
        jmp sys_chrout          ; print using the system-specific routine


print_str:
;===============================================================================
; print an ASCII, null-terminated string:
;
; in:   A       string address, lo-byte
;       Y       string address, hi-byte
;
; out:  Y       number of bytes printed
;       A       (clobbered)
;       X       (preserved)
;-------------------------------------------------------------------------------
        sta zp_screen+LO        ; load the string address into our indexer
        sty zp_screen+HI

print_str_addr:
        ;-----------------------------------------------------------------------
        ldy # 0
-       lda [zp_screen], y      ; read a character
        beq +                   ; null-terminator? exit
        jsr sys_asc2pet         ; convert to system encoding
        jsr sys_chrout          ; output to screen
        iny                     ; move to the next character
        bne -                   ; loop (but also end at 255 characters)

+       rts


print_this:
;===============================================================================
; print the ASCII, null-terminated, string that immediately follows the call
; to this routine (i.e. an inline string); this routine modifies the return
; address so that program control continues after the string
;
; out:  X       (preserved)
;       A, Y    (clobbered)
;-------------------------------------------------------------------------------
        ; this routine finds the address that called it from the return stack;
        ; when calling this routine, the return stack will look like this:
        ;
        ; stack pointer ->  (unused stack value) 
        ;               +1  original call address for string, lo-byte
        ;               +2  original call address for string, hi-byte
        ;
        .phx                    ; backup X
        tsx                     ; get current return stack pointer

        clc
        lda $0100+1, x          ; read the lo-byte from the stack
        adc # 1                 ; add 1 to move into the inline string
        sta zp_screen+LO        ; set the string address, lo-byte
        lda $0100+2, x          ; read the hi-byte from the stack
        adc # 0                 ; ripple the +1
        sta zp_screen+HI        ; set the string address, hi-byte

        jsr print_str_addr      ; print the string

        ; we will need to add the length of the inline string to the call
        ; address so as to 'step-over' those bytes and return execution to
        ; the point after the inline-string
        ;
        iny                     ; step over the null-terminator
        tya                     ; Y = length of string (1-based)
        adc $0100+1, x          ; add this to the return address, lo-byte
        sta $0100+1, x          ; write back
        bcc +                   ; ripple the carry?
        inc $0100+2, x          ; increment the return address, hi-byte

+       .plx                    ; restore X
        rts

.RAMSECTION "ZP_TEMP"   SLOT "ZP"       RETURNORG
        ;-----------------------------------------------------------------------
        ; a temporary value available for conversions
        zp_temp        .WORD
        zp_temp1        DB
        zp_temp2        DB
        ; output value
        zp_word         WORD
.ENDS


print_number_word:
;===============================================================================
; print a 16-bit binary number as decimal:
;
; adapted from:
; <http://forum.6502.org/viewtopic.php?p=55800#p55800>
;
; in:   A       lo-byte of number
;       X       hi-byte of number
;
; TODO: we may want to adpat this to 'pop' one digit at a time
;       so that we can clip against the screen edge
;-------------------------------------------------------------------------------
        sta zp_word+LO
        stx zp_word+HI

@print: lda # 0                 ; null delimiter for print
        pha

        ; divide value by 10:
@div10: lda # 0
        sta zp_temp2            ; clr BCD
        ldx # 16                ; loop counter (process 16 bits)

@loop:  asl zp_word+LO          ; value is gradually replaced
        rol zp_word+HI          ; with the quotient
        rol zp_temp2            ; BCD result is gradually replaced
        lda zp_temp2            ; with the remainder
        sec
        sbc # 10                ; partial BCD >= 10 ?
        bcc +
        sta zp_temp2            ; yes: update the partial result
        inc zp_word+LO          ; set low bit in partial quotient

+       dex
        bne @loop               ; loop 16 times
        
        lda zp_temp2
        ora # '0'               ; convert BCD result to ASCII
        pha                     ; stack digits in ascending order
        
        lda zp_word+LO
        ora zp_word+HI
        bne @div10              ; } until value is 0
        
        pla
-       ora zp_screen_mask      ; apply reverse-video, if enabled
        sta [zp_screen], y
        iny
        pla
        bne -

        rts


print_number_byte:
;===============================================================================
; this routine for converting a byte to decimal digits is adapted from:
; <https://codebase64.org/doku.php?id=base:tiny_.a_to_ascii_routine>
;
;-------------------------------------------------------------------------------
        ; hundreds:
        ;-----------------------------------------------------------------------
        sec
        ldx # '0'-1             ; increment using a screen-code digit!
-       inx                     ; increment hundreds-digit,
        sbc # 100               ; for each 100 decimal subtracted
        bcs -                   ; keep going?
        pha                     ; (put aside the remainder)

        ; we compare with "1" instead of "0" so that carry is clear for "0"
        ; and set for "1"-"9". we slide this into the flag byte to indicate
        ; later whether the middle digit should be a space or a number
        ;
        txa                     ; get hundreds-digit:
        cmp # '1'               ; is it a zero?
        bcs +
        lda # ' '               ; no hundreds digit: use a space instead
+       ora zp_screen_mask      ; apply reverse-video mode, if enabled
        sta [zp_screen], y      ; print the digit
        iny                     ; move to the next screen col

        ror.w @flag             ; (store carry in bit 7 and clear carry!)
        pla                     ; retrieve the working remainder

        ; tens & ones:
        ;-----------------------------------------------------------------------
        ldx # '9'+1             ; decrement using an ASCII digit!
-       dex                     ; decrement the tens-digit,
        adc # 10                ; for each 10 decimal subtracted
        bmi -                   ; keep going?

        adc # '0'-1             ; make it an ASCII numeral
        pha                     ; (put aside the remainder!)

        txa                     ; get tens-digit:
        rol.w @flag             ; retrieve flag to indicate padding or not
        bcs +                   ; carry set means there was a hundreds digit
                                ; so we should print a literal "0"
        cmp # '0'               ; is the digit a zero?
        bne +                   ; if not, no padding needed,
        lda # ' '               ; otherwise use padding instead
+       ora zp_screen_mask      ; apply reverse-video, if enabled
        sta [zp_screen], y      ; print the digit
        iny                     ; move to the next screen col

        pla                     ; retrieve the 1s-digit
        ora zp_screen_mask      ; apply reverse-video, if enabled
        sta [zp_screen], y      ; print the digit
        iny                     ; move to the next screen col

        rts

@flag:  .BYTE %00000000