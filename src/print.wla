; ZSheet (c) copyright Kroc Camen 2022. unless otherwise noted,
; licenced under a MIT licence; you may reuse and modify this code
; how you please as long as you retain the copyright notice
;
; print.wla : screen output
;

.RAMSECTION "ZP_TEMP"   SLOT "ZP"       RETURNORG
        ;-----------------------------------------------------------------------
        ; a temporary value available for conversions
        zp_temp        .WORD
        zp_temp1        DB
        zp_temp2        DB
        ; output value
        zp_word         WORD
.ENDS


print_char:
;===============================================================================
; print a character to the current screen position:
;
; in:   A       screen-code to print, where `zp_screen` is
;               the address of the current screen row
;       Y       offset from `zp_screen`, i.e. screen X-position
;
; out:  Y       Y is incremented by 1
;       A, X    (preserved)                                             ;+6=6
;-------------------------------------------------------------------------------
        ora zp_print_mask                                               ;+3=9
        sta [zp_screen], y                                              ;+6=15
        iny                                                             ;+2=17
        rts                                                             ;+6=23

print_char_colour:
;===============================================================================
; print a character to the current screen position and set its colour:
;
; in:   A       screen-code to print, where `zp_screen` is the address of the
;               current screen row. colour will be taken from `zp_print_colour`
;       Y       offset from `zp_screen`, i.e. screen X-position
;
; out:  Y       Y is incremented by 1
;       A, X    (preserved)                                             ;+6=6
;-------------------------------------------------------------------------------
        sta [zp_screen], y                                              ;+6=12
        lda zp_print_colour                                             ;+3=15
        sta [zp_colour], y                                              ;+6=21
        iny                                                             ;+2=23
        rts                                                             ;+6=29


print_number_word:
;===============================================================================
; print a 16-bit binary number as decimal:
;
; adapted from:
; <http://forum.6502.org/viewtopic.php?p=55800#p55800>
;
; in:   A       lo-byte of number
;       X       hi-byte of number
;
; TODO: we may want to adpat this to 'pop' one digit at a time
;       so that we can clip against the screen edge
;-------------------------------------------------------------------------------
        sta zp_word+LO
        stx zp_word+HI

@print: lda # 0                 ; null delimiter for print
        pha

        ; divide value by 10:
@div10: lda # 0
        sta zp_temp2            ; clr BCD
        ldx # 16                ; loop counter (process 16 bits)

@loop:  asl zp_word+LO          ; value is gradually replaced
        rol zp_word+HI          ; with the quotient
        rol zp_temp2            ; BCD result is gradually replaced
        lda zp_temp2            ; with the remainder
        sec
        sbc # 10                ; partial BCD >= 10 ?
        bcc +
        sta zp_temp2            ; yes: update the partial result
        inc zp_word+LO          ; set low bit in partial quotient

+       dex
        bne @loop               ; loop 16 times
        
        lda zp_temp2
        ora # '0'               ; convert BCD result to ASCII
        pha                     ; stack digits in ascending order
        
        lda zp_word+LO
        ora zp_word+HI
        bne @div10              ; } until value is 0
        
        pla
-       ora zp_print_mask       ; apply reverse-video, if enabled
        sta [zp_screen], y
        iny
        pla
        bne -

        rts


print_number_byte:
;===============================================================================
; print a single byte value as a space-padded decimal:
; (3 characters are always printed)
;
; this routine for converting a byte to decimal digits is adapted from:
; <https://codebase64.org/doku.php?id=base:tiny_.a_to_ascii_routine>,
; Kroc added the space-padding
;
; in:   A       binary number 0-255 to print in decimal
;       Y       offset from `zp_screen` to print at
; out:  Y       the screen offset is moved forward
;               by the number of printed chars
;       X       (preserved)
;       A       (clobbered)
;-------------------------------------------------------------------------------
        stx.w @ldx+1            ; preserve X

        ; hundreds:
        ;-----------------------------------------------------------------------
        sec
        ldx # '0'-1             ; increment using a screen-code digit!
-       inx                     ; increment hundreds-digit,
        sbc # 100               ; for each 100 decimal subtracted
        bcs -                   ; keep going?
        pha                     ; (put aside the remainder)

        ; we compare with "1" instead of "0" so that carry is clear for "0"
        ; and set for "1"-"9". we slide this into the flag byte to indicate
        ; later whether the middle digit should be a space or a number
        ;
        txa                     ; get hundreds-digit:
        cmp # '1'               ; is it a zero?
        bcs +
        lda # ' '               ; no hundreds digit: use a space instead
+       ora zp_print_mask       ; apply reverse-video mode, if enabled
        sta [zp_screen], y      ; print the digit
        iny                     ; move to the next screen col

        ror.w @flag             ; (store carry in bit 7 and clear carry!)
        pla                     ; retrieve the working remainder

        ; tens:
        ;-----------------------------------------------------------------------
        ldx # '9'+1             ; decrement using an ASCII digit!
-       dex                     ; decrement the tens-digit,
        adc # 10                ; for each 10 decimal subtracted
        bmi -                   ; keep going?

        adc # '0'-1             ; make it an ASCII numeral
        pha                     ; (put aside the remainder!)

        txa                     ; get tens-digit:
        rol.w @flag             ; retrieve flag to indicate padding or not
        bcs +                   ; carry set means there was a hundreds digit
                                ; so we should print a literal "0"
        cmp # '0'               ; is the digit a zero?
        bne +                   ; if not, no padding needed,
        lda # ' '               ; otherwise use padding instead
+       ora zp_print_mask       ; apply reverse-video, if enabled
        sta [zp_screen], y      ; print the digit
        iny                     ; move to the next screen col

        ; ones:
        ;-----------------------------------------------------------------------
        pla                     ; retrieve the 1s-digit
        ora zp_print_mask       ; apply reverse-video, if enabled
        sta [zp_screen], y      ; print the digit
        iny                     ; move to the next screen col

@ldx    ldx # $00               ; restore X
        rts

@flag:  .BYTE %00000000